<!doctype html>
<html class="theme-next use-motion ">
<head>
    

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>



  <link href='//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.4"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.4" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Vitrum's Blog">
<meta property="og:url" content="http://vitrum.github.io/index.html">
<meta property="og:site_name" content="Vitrum's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Vitrum's Blog">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

    <title> Vitrum's Blog </title>
</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="">
<!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->




<div class="container one-column 
   page-home 
">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-logo"></i>
      </span>
      <span class="site-title">Vitrum's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-home"></i> <br />
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-about"></i> <br />
            關於
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-archives"></i> <br />
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-tags"></i> <br />
            標籤
          </a>
        </li>
      
    </ul>
  

  
</nav>


        </div>
    </header>

    <main id="main" class="main">
        <div class="main-inner">
            <div id="content" class="content">
                
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/09/06/当输入网址按下回车键之后/" itemprop="url">
                当输入网址按下回车键之后 (转)
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-09-06T20:36:52+08:00" content="2015-09-06">
            2015-09-06
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h1 id="当输入网址按下回车键之后发生了什么_(转)？">当输入网址按下回车键之后发生了什么 (转)？</h1><p><a href="https://github.com/skyline75489/what-happens-when-zh_CN" target="_blank" rel="external">https://github.com/skyline75489/what-happens-when-zh_CN</a></p>
<p>What-happens-when 的中文翻译，原仓库 <a href="https://github.com/alex/what-happens-when" target="_blank" rel="external">https://github.com/alex/what-happens-when</a></p>
<p>===================</p>
<p>这个仓库试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？</p>
<p>不过我们不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。</p>
<p>这将是一个协作的过程，所以深入挖掘吧，并且帮助我们一起完善它。仍然有大量的细节等待着你来添加，欢迎向我们发送 Pull Requset！</p>
<p>这些内容使用 <code>Creative Commons Zero</code>_ 协议发布。</p>
<h1 id="目录">目录</h1><p>.. contents::<br>   :backlinks: none<br>   :local:</p>
<h2 id="按下”g”键">按下”g”键</h2><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下“g”键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 “google.com”，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 “google.com” 建议给你。</p>
<h2 id="回车键按下">回车键按下</h2><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。</p>
<p><em>USB键盘：</em></p>
<ul>
<li><p>键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压</p>
</li>
<li><p>键码值存储在键盘内部电路一个叫做”endpoint”的寄存器内</p>
</li>
<li><p>USB控制器大概每隔10ms便查询一次”endpoint”以得到存储的键码值数据，这个最短时间间隔由键盘提供</p>
</li>
<li><p>键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包</p>
</li>
<li><p>这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成”低速设备”（USB 2.0 compliance）</p>
</li>
<li><p>这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</p>
</li>
</ul>
<p><em>虚拟键盘（触屏设备）：</em></p>
<ul>
<li><p>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次“点击”的坐标</p>
</li>
<li><p>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个GUI部件上了，现在这个部件是虚拟键盘的按钮</p>
</li>
<li><p>虚拟键盘引发一个软中断，返回给OS一个“按键按下”消息</p>
</li>
<li><p>这个消息又返回来向当前活跃的应用通知一个“按键按下”事件</p>
</li>
</ul>
<h2 id="产生中断[非USB键盘]">产生中断[非USB键盘]</h2><p>键盘在它的中断请求线(IRQ)上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU使用中断描述符表(IDT)把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU根据IDT和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p>
<h2 id="(Windows)一个_WM_KEYDOWN_消息被发往应用程序">(Windows)一个 <code>WM_KEYDOWN</code> 消息被发往应用程序</h2><p>HID把键盘按下的事件传送给 <code>KBDHID.sys</code> 驱动，把HID的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 <code>VK_RETURN(0x0d)</code>。 <code>KBDHID.sys</code> 驱动和 <code>KBDCLASS.sys</code> (键盘类驱动,keyboard class driver)进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 <code>Win32K.sys</code> ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p>
<p><code>Win32K.sys</code> 通过 <code>GetForegroundWindow()</code> API函数找到当前哪个窗口是活跃的。这个API函数提供了当前浏览器的地址栏的句柄。Windows系统的”message pump”机制调用 <code>SendMessage(hWnd, WM_KEYDOWN, VK_RETURN, lParam)</code> 函数， <code>lParam</code> 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是0），实际扫描码（可能依赖于OEM厂商，不过通常不会是 <code>VK_RETURN</code> ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p>
<p>Windows的 <code>SendMessage</code> API直接将消息添加到特定窗口句柄 <code>hWnd</code> 的消息队列中，之后赋给 <code>hWnd</code> 的主要消息处理函数 <code>WindowProc</code> 将会被调用，用于处理队列中的消息。</p>
<p>当前活跃的句柄 <code>hWnd</code> 实际上是一个edit control控件，这种情况下，<code>WindowProc</code> 有一个用于处理 <code>WM_KEYDOWN</code> 消息的处理器，这段代码会查看 <code>SendMessage</code> 传入的第三个参数 <code>wParam</code> ，因为这个参数是 <code>VK_RETURN</code> ，于是它知道用户按下了回车键。</p>
<h2 id="(Mac_OS_X)一个_KeyDown_NSEvent被发往应用程序">(Mac OS X)一个 <code>KeyDown</code> NSEvent被发往应用程序</h2><p>中断信号引发了I/O Kit Kext键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X的 <code>WindowServer</code> 进程。然后， <code>WindowServer</code> 将这个事件通过Mach端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 <code>mach_ipc_dispatch</code> 函数读取到。这个过程通常是由 <code>NSApplication</code> 主事件循环产生并且处理的，通过 <code>NSEventType</code> 为 <code>KeyDown</code> 的 <code>NSEvent</code> 。</p>
<h2 id="(GNU/Linux)Xorg_服务器监听键码值">(GNU/Linux)Xorg 服务器监听键码值</h2><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器(DWM，metacity, i3等等)，窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形API把文字打印在输入框内。</p>
<h2 id="解析URL">解析URL</h2><ul>
<li><p>浏览器通过 URL 能够知道下面的信息：</p>
<ul>
<li><code>Protocol</code> “http”<br>  使用HTTP协议</li>
<li><code>Resource</code> “/“<br>  请求的资源是主页(index)</li>
</ul>
</li>
</ul>
<h2 id="输入的是_URL_还是搜索的关键字？">输入的是 URL 还是搜索的关键字？</h2><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p>
<h2 id="检查_HSTS_列表···">检查 HSTS 列表···</h2><ul>
<li>浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表，这个列表里包含了那些请求浏览器只使用HTTPS进行连接的网站</li>
<li>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用HTTP协议发送</li>
<li>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户收到 <code>downgrade attack</code>_ 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</li>
</ul>
<h2 id="转换非_ASCII_的_Unicode_字符">转换非 ASCII 的 Unicode 字符</h2><ul>
<li>浏览器检查输入是否含有不是 <code>a-z</code>， <code>A-Z</code>，<code>0-9</code>， <code>-</code> 或者 <code>.</code> 的字符</li>
<li>这里主机名是 <code>google.com</code> ，所以没有非ASCII的字符，如果有的话，浏览器会对主机名部分使用 <code>Punycode</code>_  编码</li>
</ul>
<h2 id="DNS_查询···">DNS 查询···</h2><ul>
<li>浏览器检查域名是否在缓存当中</li>
<li>如果缓存中没有，就去调用 <code>gethostbyname</code> 库函数（操作系统不同函数也不同）进行查询</li>
<li><code>gethostbyname</code> 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置 <code>不同的操作系统有所不同</code>_</li>
<li><p>如果 <code>gethostbyname</code> 没有这个域名的缓存记录，也没有在 <code>hosts</code> 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</p>
</li>
<li><p>查询本地 DNS 服务器</p>
</li>
<li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li>
<li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li>
</ul>
<h2 id="ARP">ARP</h2><p>要想发送 ARP 广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p>
<ul>
<li>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC</li>
</ul>
<p>如果缓存没有命中：</p>
<ul>
<li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li>
<li>查询选择的网络接口的 MAC 地址</li>
<li>我们发送一个二层 ARP 请求：</li>
</ul>
<p><code>ARP Request</code>::</p>
<pre><code>Sender MAC: interface:mac:<span class="tag">address</span>:here
Sender IP: interface<span class="class">.ip</span><span class="class">.goes</span><span class="class">.here</span>
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target<span class="class">.ip</span><span class="class">.goes</span><span class="class">.here</span>
</code></pre><p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p>
<p>直连：</p>
<ul>
<li>如果我们和路由器是直接连接的，路由器会返回一个 <code>ARP Reply</code> （见下面）。</li>
</ul>
<p>集线器：</p>
<ul>
<li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code> 。</li>
</ul>
<p>交换机：</p>
<ul>
<li>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li>
<li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li>
<li>如果路由器也“连接”在其中，它会返回一个 <code>ARP Reply</code></li>
</ul>
<p><code>ARP Reply</code>::</p>
<pre><code>Sender MAC: target:mac:<span class="tag">address</span>:here
Sender IP: target<span class="class">.ip</span><span class="class">.goes</span><span class="class">.here</span>
Target MAC: interface:mac:<span class="tag">address</span>:here
Target IP: interface<span class="class">.ip</span><span class="class">.goes</span><span class="class">.here</span>
</code></pre><p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p>
<ul>
<li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li>
<li>如果本地/ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li>
</ul>
<h2 id="使用套接字">使用套接字</h2><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 <code>socket</code> ，请求一个<br>TCP流套接字，对应的参数是 <code>AF_INET</code> 和 <code>SOCK_STREAM</code> 。</p>
<ul>
<li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是ip_local_port_range)</li>
<li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的IP地址以及本机的IP地址，把它封装成一个TCP packet。</li>
<li>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame头 部，里面包含了本地内置网卡的MAC地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。</li>
</ul>
<p>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p>
<ul>
<li><code>以太网</code>_</li>
<li><code>WiFi</code>_</li>
<li><code>蜂窝数据网络</code>_</li>
</ul>
<p>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个 <code>网络节点</code>_ 处理。节点的目标地址和源地址将在后面讨论。</p>
<p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个 <code>网络节点</code>_ 进行处理。</p>
<p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP数据报头部TTL域的值每经过一个路由器就减1，如果封包的TTL变为0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p>
<p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p>
<ul>
<li>客户端选择一个初始序列号(ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</li>
<li>服务器端接收到 SYN 包，如果它可以建立连接：<ul>
<li>服务器端选择它自己的初始序列号</li>
<li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li>
<li>服务器端把 (客户端ISN + 1) 复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li>
</ul>
</li>
<li>客户端通过发送下面一个封包来确认这次连接：<ul>
<li>自己的序列号+1</li>
<li>接收端 ACK+1</li>
<li>设置 ACK 位</li>
</ul>
</li>
<li>数据通过下面的方式传输：<ul>
<li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li>
<li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li>
</ul>
</li>
<li>关闭连接时：<ul>
<li>要关闭连接的一方发送一个 FIN 包</li>
<li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li>
<li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li>
</ul>
</li>
</ul>
<p>UDP 数据包<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="header">TLS 握手</span><br><span class="line">--------</span></span><br><span class="line"><span class="bullet">* </span>客户端发送一个 <span class="code">``Client hello`</span>` 消息到服务器端，消息中同时包含了它的TLS版本，可用的加密算法和压缩算法。</span><br><span class="line"><span class="bullet">* </span>服务器端向客户端返回一个 <span class="code">``Server hello`</span>` 消息，消息中包含了服务器端的TLS版本，服务器选择了哪个加密和压缩算法，以及服务器的公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</span><br><span class="line"><span class="bullet">* </span>客户端根据自己的信任CA列表，验证服务器端的证书是否有效。如果有效，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</span><br><span class="line"><span class="bullet">* </span>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</span><br><span class="line"><span class="bullet">* </span>客户端发送一个 <span class="code">``Finished`</span>` 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</span><br><span class="line"><span class="bullet">* </span>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 <span class="code">``Finished`</span>` 消息，也使用协商好的对称密钥加密</span><br><span class="line"><span class="bullet">* </span>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</span><br><span class="line"></span><br><span class="line">TCP 数据包</span><br><span class="line">~</span><br></pre></td></tr></table></figure></p>
<h2 id="HTTP_协议···">HTTP 协议···</h2><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p>
<p>如果浏览器使用 HTTP 协议，它会向服务器发送这样的一个请求::</p>
<pre><code>GET <span class="regexp">/ HTTP/</span><span class="number">1.1</span>
<span class="string">Host:</span> google.com
[其他头部]
</code></pre><p>“其他头部”包含了一系列的由冒号分割开的键值对，它们的格式符合HTTP协议标准，它们之间由一个换行符分割开来。这里我们假设浏览器没有违反HTTP协议标准的bug，同时浏览器使用 <code>HTTP/1.1</code> 协议，不然的话头部可能不包含 <code>Host</code> 字段，同时 <code>GET</code> 请求中的版本号会变成 <code>HTTP/1.0</code> 或者 <code>HTTP/0.9</code> 。</p>
<p>HTTP/1.1 定义了“关闭连接”的选项 “close”，发送者使用这个选项指示这次连接在响应结束之后会断开::</p>
<pre><code><span class="label">Connection:</span>close
</code></pre><p>不支持持久连接的 HTTP/1.1 必须在每条消息中都包含 “close” 选项。 </p>
<p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p>
<p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的::</p>
<pre><code><span class="keyword">200</span> OK<span class="sqbracket">
[响应头部]</span>
</code></pre><p>然后是一个换行，接下来有效载荷(payload)，也就是 <code>www.google.com</code> 的HTML内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供以后的请求重用。</p>
<p>如果浏览器发送的HTTP头部包含了足够多的信息（例如包含了 Etag 头部，以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应::</p>
<pre><code><span class="keyword">304</span> Not Modified<span class="sqbracket">
[响应头部]</span>
</code></pre><p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p>
<p>在解析完 HTM L之后，浏览器和客户端会重复上面的过程，直到HTML页面引入的所有资源（图片，CSS，favicon.ico等等）全部都获取完毕，区别只是头部的 <code>GET / HTTP/1.1</code> 会变成 <code>GET /$(相对www.google.com的URL) HTTP/1.1</code> 。 </p>
<p>如果HTML引入了 <code>www.google.com</code> 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 <code>Host</code> 头部会变成另外的域名。</p>
<h2 id="HTTP_服务器请求处理">HTTP 服务器请求处理</h2><p>HTTPD(HTTP Daemon)在服务器端处理请求/相应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p>
<ul>
<li>HTTPD 接收请求</li>
<li>服务器把请求拆分为以下几个参数：<ul>
<li>HTTP 请求方法(GET, POST, HEAD, PUT 和 DELETE)。在访问 Google 这种情况下，使用的是 GET 方法</li>
<li>域名：google.com</li>
<li>请求路径/页面：/  (我们没有请求google.com下的指定的页面，因此 / 是默认的路径)</li>
</ul>
</li>
<li>服务器验证其上已经配置了 google.com 的虚拟主机</li>
<li>服务器验证 google.com 接受 GET 方法</li>
<li>服务器验证该用户可以使用 GET 方法(根据 IP 地址，身份信息等)</li>
<li>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</li>
<li>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是 “/“ ,会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</li>
<li>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</li>
</ul>
<h2 id="浏览器背后的故事">浏览器背后的故事</h2><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p>
<ul>
<li>解析 HTML，CSS，JS</li>
<li>渲染——构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li>
</ul>
<h2 id="浏览器">浏览器</h2><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI(Uniform Resource Identifier) 来确定。</p>
<p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C(World Wide Web Consortium) 维护。</p>
<p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p>
<ul>
<li>一个地址栏</li>
<li>后退和前进按钮</li>
<li>书签选项</li>
<li>刷新和停止按钮</li>
<li>主页按钮</li>
</ul>
<p><strong>浏览器高层架构</strong></p>
<p>组成浏览器的组件有：</p>
<ul>
<li><strong>用户界面</strong> 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li>
<li><strong>浏览器引擎</strong> 浏览器引擎负责让 UI 和渲染引擎协调工作</li>
<li><strong>渲染引擎</strong> 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li>
<li><strong>网络组件</strong> 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li>
<li><strong>UI后端</strong> UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li>
<li><strong>Javascript 引擎</strong> Javascript 引擎用于解析和执行 Javascript 代码</li>
<li><strong>数据存储</strong> 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li>
</ul>
<h2 id="HTML_解析">HTML 解析</h2><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成8kB大小的分块传输。</p>
<p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p>
<p>解析树是以 DOM 元素以及属性为节点的树。DOM是文档对象模型(Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部(如Javascript)的接口。树的根部是”Document”对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p>
<p><strong>解析算法</strong></p>
<p>HTML不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p>
<ul>
<li>语言本身的“宽容”特性</li>
<li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li>
<li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 <code>document.write()</code> 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li>
</ul>
<p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p>
<p><strong>解析结束之后</strong></p>
<p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p>
<p>此时浏览器把文档标记为“可交互的”，浏览器开始解析处于“推迟”模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为“完成”，浏览器会进行“加载”事件。</p>
<p>注意解析 HTML 网页时永远不会出现“语法错误”，浏览器会修复所有错误，然后继续解析。</p>
<p>执行同步 Javascript 代码。</p>
<h2 id="CSS_解析">CSS 解析</h2><ul>
<li>根据 <code>CSS词法和句法</code>_ 分析CSS文件和 <code>&lt;style&gt;</code> 标签包含的内容</li>
<li>每个CSS文件都被解析成一个样式表对象，这个对象里包含了带有选择器的CSS规则，和对应CSS语法的对象</li>
<li>CSS解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</li>
</ul>
<h2 id="页面渲染">页面渲染</h2><ul>
<li>通过遍历DOM节点树创建一个“Frame 树”或“渲染树”，并计算每个节点的各个CSS样式值</li>
<li>通过累加子节点的宽度，该节点的水平内边距(padding)、边框(border)和外边距(margin)，自底向上的计算”Frame 树”中每个节点首的选(preferred)宽度</li>
<li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li>
<li>通过应用文字折行、累加子节点的高度和此节点的内边距(padding)、边框(border)和外边距(margin)，自底向上的计算每个节点的高度</li>
<li>使用上面的计算结果构建每个节点的坐标</li>
<li>当存在元素使用 <code>floated</code>，位置有 <code>absolutely</code> 或 <code>relatively</code> 属性的时候，会有更多复杂的计算，详见<a href="http://dev.w3.org/csswg/css2/" target="_blank" rel="external">http://dev.w3.org/csswg/css2/</a> 和 <a href="http://www.w3.org/Style/CSS/current-work" target="_blank" rel="external">http://www.w3.org/Style/CSS/current-work</a></li>
<li>创建layer(层)来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li>
<li>页面上的每个层都被分配了纹理(?)</li>
<li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由CPU执行栅格化处理，或者直接通过D2D/SkiaGL在GPU上绘制</li>
<li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li>
<li>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL发出，GPU命令缓冲区清空，命令传至GPU并异步渲染，帧被送到Window Server。</li>
</ul>
<h2 id="GPU_渲染">GPU 渲染</h2><ul>
<li>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU</li>
<li>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li>
</ul>
<h2 id="Window_Server">Window Server</h2><h2 id="后期渲染与用户引发的处理">后期渲染与用户引发的处理</h2><p>渲染结束后，浏览器根据某些时间机制运行JavaScript代码(比如Google Doodle动画)或与用户交互(在搜索栏输入关键字获得搜索建议)。类似Flash和Java的插件也会运行，尽管Google主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>
<p>.. <em><code>Creative Commons Zero</code>: <a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" rel="external">https://creativecommons.org/publicdomain/zero/1.0/</a><br>.. </em><code>CSS词法和句法</code>: <a href="http://www.w3.org/TR/CSS2/grammar.html" target="_blank" rel="external">http://www.w3.org/TR/CSS2/grammar.html</a><br>.. <em><code>Punycode</code>: <a href="https://en.wikipedia.org/wiki/Punycode" target="_blank" rel="external">https://en.wikipedia.org/wiki/Punycode</a><br>.. </em><code>以太网</code>: <a href="http://en.wikipedia.org/wiki/IEEE_802.3" target="_blank" rel="external">http://en.wikipedia.org/wiki/IEEE_802.3</a><br>.. <em><code>WiFi</code>: <a href="https://en.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="external">https://en.wikipedia.org/wiki/IEEE_802.11</a><br>.. </em><code>蜂窝数据网络</code>: <a href="https://en.wikipedia.org/wiki/Cellular_data_communication_protocol" target="_blank" rel="external">https://en.wikipedia.org/wiki/Cellular_data_communication_protocol</a><br>.. <em><code>analog-to-digital converter</code>: <a href="https://en.wikipedia.org/wiki/Analog-to-digital_converter" target="_blank" rel="external">https://en.wikipedia.org/wiki/Analog-to-digital_converter</a><br>.. </em><code>网络节点</code>: <a href="https://en.wikipedia.org/wiki/Computer_network#Network_nodes" target="_blank" rel="external">https://en.wikipedia.org/wiki/Computer_network#Network_nodes</a><br>.. <em><code>不同的操作系统有所不同</code> : <a href="https://en.wikipedia.org/wiki/Hosts" target="_blank" rel="external">https://en.wikipedia.org/wiki/Hosts</a></em>%28file%29#Location<em>in_the_file_system<br>.. </em><code>downgrade attack</code>: <a href="http://en.wikipedia.org/wiki/SSL_stripping" target="_blank" rel="external">http://en.wikipedia.org/wiki/SSL_stripping</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/28/制作OSX-10-11-El-Capitan-的USB安装盘/" itemprop="url">
                制作OSX 10.11 El Capitan 的USB安装盘
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-28T15:00:31+08:00" content="2015-08-28">
            2015-08-28
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>OS X El Capitan传说9月9日就要发正式了，碰巧我电脑换了硬盘，干脆装一个耍耍～</p>
<p>特此收集了一下USB安装盘的做法，貌似和以前10.10的做法类似。</p>
<h2 id="准备工作">准备工作</h2><ul>
<li>首先要准备一个8G以上的U盘，我特地去买了个支持type-c的U盘，以后可以用来installB</li>
<li><a href="https://developer.apple.com/osx/download/" target="_blank" rel="external">去APPLE开发者社区下载测试版</a></li>
<li>一台能装OS X El Capitan的电脑</li>
<li>确认在”/Applications/“目录中已经正确下载了安装文件：”Install OS X El Capitan Developer Beta.app”</li>
<li>如果是在网盘上下载压缩包的，记得解压缩之后复制”Install OS X El Capitan Developer Beta.app”到/“Applications/“目录去</li>
</ul>
<p>如果要把本地下载好的.app压缩打包上网盘，可能需要切分</p>
<h2 id="支持安装OS_X_El_Capitan的电脑">支持安装OS X El Capitan的电脑</h2><ul>
<li>iMac (Mid-2007 or, newer)</li>
<li>MacBook (13in Aluminum, Late 2008), (13in, Early 2009 or, newer)</li>
<li>MacBook Pro (13in, Mid-2009 or, newer), (15in, Mid/Late 2007 or, newer), (17in, Late 2007 or, newer)</li>
<li>MacBook Air (Late 2008 or, newer)</li>
<li>Mac Mini (Early 2009 or, newer)</li>
<li>Mac Pro (Early 2008 or, newer)</li>
<li>Xserve (Early 2009)</li>
</ul>
<h2 id="现在开始制作安装U盘">现在开始制作安装U盘</h2><h3 id="第一步_格式化U盘">第一步 格式化U盘</h3><p><img src="http://ips.chotee.com/wp-content/uploads/2014/osx-yosemite-usb-install-drive/format-usb.jpg" alt="http://ips.chotee.com/wp-content/uploads/2014/osx-yosemite-usb-install-drive/format-usb.jpg"></p>
<ul>
<li>1 - 在左方列表中找到 U 盘的名称并点击</li>
<li>右边顶部选择 2 -「分区」，然后在 3 -「分区布局」选择「1个分区」</li>
<li>在分区信息中的 4 -「名称」输入「ElCapInstaller」 (由于后面的命令中会用到此名称，如果你要修改成其他(英文)，请务必对应修改后面的命令)</li>
<li>在「格式」中选择 5 -「Mac OS 扩展 (日志式)」</li>
<li>这时，先别急着点“应用”，还要先在 6 -「选项」里面，如下图</li>
</ul>
<p><img src="http://ips.chotee.com/wp-content/uploads/2014/osx-yosemite-usb-install-drive/guid.jpg" alt="http://ips.chotee.com/wp-content/uploads/2014/osx-yosemite-usb-install-drive/guid.jpg"></p>
<ul>
<li>选择「GUID 分区表」，然后点击「好」</li>
<li>最后再点「应用」开始对 U 盘进行格式化。<br>*</li>
</ul>
<h3 id="第二步_输入终端命令开始制作启动盘">第二步 输入终端命令开始制作启动盘</h3><p>打开终端窗口，输入下面的命令</p>
<p>这里是和我下载的文件名一样的</p>
<pre><code>sudo /Applications/Install<span class="string">\</span> OS<span class="string">\</span> X<span class="string">\</span> El<span class="string">\</span> Capitan<span class="string">\</span> Developer<span class="string">\</span> Beta.app/Contents/Resources/createinstallmedia --volume /Volumes/ElCapInstaller --applicationpath /Applications/Install<span class="string">\</span> OS<span class="string">\</span> X<span class="string">\</span> El<span class="string">\</span> Capitan<span class="string">\</span> Developer<span class="string">\</span> Beta.app --nointeraction
</code></pre><p>For OS X El Capitan Public Beta:</p>
<pre><code>sudo /Applications/Install<span class="string">\</span> OS<span class="string">\</span> X<span class="string">\</span> El<span class="string">\</span> Capitan<span class="string">\</span> Public<span class="string">\</span> Beta.app/Contents/Resources/createinstallmedia --volume /Volumes/ElCapInstaller --applicationpath /Applications/Install<span class="string">\</span> OS<span class="string">\</span> X<span class="string">\</span> El<span class="string">\</span> Capitan<span class="string">\</span> Public<span class="string">\</span> Beta.app --nointeraction
</code></pre><p>For OS X 10.11 Developer Beta:</p>
<pre><code>sudo /Applications/Install<span class="string">\</span> OS<span class="string">\</span> X<span class="string">\</span> <span class="number">10.11</span><span class="string">\</span> Developer<span class="string">\</span> Beta.app/Contents/Resources/createinstallmedia --volume /Volumes/ElCapInstaller --applicationpath /Applications/Install<span class="string">\</span> OS<span class="string">\</span> X<span class="string">\</span> <span class="number">10.11</span><span class="string">\</span> Developer<span class="string">\</span> Beta.app --nointeraction
</code></pre><p>然后按下“回车” 键，等待结果</p>
<h3 id="第三步_顺利的话输出这个">第三步 顺利的话输出这个</h3><pre><code>“Erasing Disk: 0%… 10%… 20%… 30%…100%…
Copying installer files to disk…
<span class="built_in">Copy</span> <span class="bash">complete.
</span>Making disk bootable…
Copying boot files…
<span class="built_in">Copy</span> <span class="bash">complete.
</span>Done.”
</code></pre><p>看到Done就是说明好了，期间要等待好长时间，请喝杯茶，走一走，程序员要预防颈椎病～</p>
<h3 id="第四步_测试一下">第四步 测试一下</h3><p>把做好的U盘推出系统，然后再插一下（好像很邪恶的说）。</p>
<p>如果正常就会弹出安装界面。</p>
<h2 id="另外">另外</h2><p>新系统常常伴随着各种问题，勇作小白鼠真是伟大的情操。如果你有重要的资料请做好备份，或者可以再开一个分区，在分区里安装。</p>
<p>参考：</p>
<ul>
<li><a href="http://www.ibtimes.co.uk/os-x-10-11-el-capitan-how-make-bootable-usb-installer-drive-1505947" target="_blank" rel="external">OS X 10.11 El Capitan: How to make bootable USB installer drive</a></li>
</ul>
<ul>
<li><a href="http://www.iplaysoft.com/osx-yosemite-usb-install-drive.html" target="_blank" rel="external">简单制作 OS X Yosemite 10.10 正式版U盘USB启动安装盘方法教程 (全新安装 Mac 系统)</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/26/Thunk函数/" itemprop="url">
                Thunk函数
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-26T14:54:34+08:00" content="2015-08-26">
            2015-08-26
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="缘起">缘起</h2><p>某天在看reack的文档时看到，这个Thunk词好像很屌，在ES6中做回调函数。搜索果然大有历史啊。（我基础太渣啊）</p>
<p><a href="https://en.wikipedia.org/wiki/Thunk" target="_blank" rel="external">Wiki上这么介绍</a></p>
<p>Thunk:形实转换程序, 1961年由Prof.Peter Ingerman发明，当时是在 ALGOL 60 语言里。</p>
<p>说实话我还没搞懂，先挖坑，以后再填</p>
<h2 id="堆资料">堆资料</h2><ul>
<li><a href="https://gist.github.com/1571493" target="_blank" rel="external">Thunk in Javascript</a></li>
<li><a href="http://blog.csdn.net/chenyujing1234/article/details/7443084?utm_source=tuicool" target="_blank" rel="external">WTL中 Thunk技术本质(含代码)</a></li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/24/云上的数据/" itemprop="url">
                云上的数据
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-24T15:35:51+08:00" content="2015-08-24">
            2015-08-24
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="一开始只是随便看看">一开始只是随便看看</h2><p>上周在看react的todo例子时碰巧看到了一个基于<a href="http://todomvc.com/examples/firebase-angular/#/" target="_blank" rel="external">Firebase + AngularJS的实时TODO项目</a>，感觉挺有趣的。这样的架构，就不需要为设置数据库服务而头疼了，甚至不需要为一个小应用花一毛钱。</p>
<p>简单来说，Firebase是一个提供实时数据的云服务平台，网页、APP应用使用它的接口就可以做到实时的数据同步。两个人在不同的电脑上打开了同一个应用，其中一个人在网页上进行了操作，网页上产生的变化就会实时在另一个人的APP上表现出来。</p>
<p>Firebase还提供了<a href="https://www.firebase.com/docs/web/libraries/" target="_blank" rel="external">主流JS框架支持</a>，为Angular,Ember,React,Backbone,Ionic什么都写了库，对前端开发来说是不错的利好消息。</p>
<h2 id="BaaS">BaaS</h2><p>BaaS（后端即服务：Backend as a Service）指为移动应用开发者提供整合云后端的边界服务。</p>
<h2 id="国内的替代项目">国内的替代项目</h2><p>不过，他们在2014年10月份爆出新闻，被谷歌收购了。然后，我觉得可能需要找国内替代品了。</p>
<h3 id="Bmob"><a href="http://www.bmob.cn/" target="_blank" rel="external">Bmob</a></h3><p><img src="http://cms.csdnimg.cn/article/201303/06/5136fcc1b8b01.jpg" alt="Bmob"></p>
<p>Bmob是国内第一家专注于移动应用云存储的平台，是基于PaaS模式的云计算平台。开发者可以使用Bmob设计存储框架、获取应用密钥、下载SDK并嵌入应用程序、调用相应API，应用发布后查看存储的统计分析数据，整个流程能够快速实现，并且Bmob的云服务是免费的。</p>
<h3 id="野狗"><a href="https://www.wilddog.com/" target="_blank" rel="external">野狗</a></h3><p><img src="https://cdn.wilddog.com/www-nd/images/index/index-title-first.c2f9b30a.svg" alt="wilddog"></p>
<p>野狗，是国内第一家实时PaaS服务提供商，其创始团队来自360、人人网、百度等一线公司，之所以起了这个名字，除了能够让人过耳不忘之外，还因为其创始人刘之自认为性格偏向野性，对事业极具野心，因而自比“野狗”。</p>
<p>目前野狗的方向是做物联网后端数据云服务，是国内首家支持物联网国际标准CoAP (Constrained Application Protocol)的云服务商。CoAP采用UDP传输层协议来进行通讯，更适合在Google Thread等资源受限设备。CoAP比传统协议节省至少10倍流量，电池使用更加持久。</p>
<h2 id="资料">资料</h2><p><a href="http://www.html-js.com/article/Using-Angular-to-develop-web-application-with-AngularJS-and-Firebase-to-produce-a-real-time-polling-application" target="_blank" rel="external">用AngularJS和Firebase制作一个实时投票应用</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/10/Bitwise-Operation/" itemprop="url">
                Javascript Bitwise Operation
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-10T17:50:17+08:00" content="2015-08-10">
            2015-08-10
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>话说有个编程题目，有两个整数a和b, 求他们的和, 但不能使用 + 等数学运算符。</p>
<p>这是<a href="https://oj.leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">leetcode</a>上的题目，需要用<a href="https://en.wikipedia.org/wiki/Bitwise_operation" target="_blank" rel="external">位运算</a>处理。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/5c/Rotate_left_logically.svg" alt="Rotate left logically"></p>
<p>例如：</p>
<pre><code><span class="label">int</span> <span class="keyword">Add(int </span>a, int <span class="keyword">b)
</span>{
    return <span class="keyword">b </span>? <span class="keyword">Add(a^b, </span>(a&amp;<span class="keyword">b)&lt;&lt;1) </span>: a<span class="comment">;</span>
}
</code></pre><p>其实在Javascript中也有位运算，只是平时很少用到。例如下面这段摘抄的代码，可以猜猜生成什么：</p>
<pre><code><span class="keyword">var</span> a = <span class="string">"10"</span>| 0 ;
console.<span class="literal">log</span>(<span class="string">"Bitwise Or a is : "</span> +a);
<span class="keyword">var</span> b = <span class="string">"s1132"</span>|0;
console.<span class="literal">log</span>(<span class="string">"Bitwise Or b is : "</span> +b);
<span class="keyword">var</span> c = [1,3,2]&amp;1 ;
console.<span class="literal">log</span>(<span class="string">"Bitwise And c is : "</span> +c);
<span class="keyword">var</span> <span class="keyword">d</span> = [1]|0;
console.<span class="literal">log</span>(<span class="string">"Bitwise Or d is : "</span> +<span class="keyword">d</span>);
<span class="keyword">var</span> <span class="keyword">e</span> = ~function(){}();
console.<span class="literal">log</span>(<span class="string">"Bitwise Not e is : "</span> +<span class="keyword">e</span>);
<span class="keyword">var</span> f = ({})|0;
console.<span class="literal">log</span>(<span class="string">"Bitwise Or f is : "</span> +f);
<span class="keyword">var</span> <span class="keyword">g</span> = ([1])|0;
console.<span class="literal">log</span>(<span class="string">"Bitwise Or g is : "</span> +<span class="keyword">g</span>);
<span class="keyword">var</span> <span class="keyword">h</span> = <span class="string">"1ss"</span>^0;
console.<span class="literal">log</span>(<span class="string">"Bitwise Exclusive Or h is : "</span> +<span class="keyword">h</span>);
</code></pre><h2 id="javascript中的位运算">javascript中的位运算</h2><p>　　javascript中的位运算非常复杂，由于javascript试图创建完全无类型（弱类型）的数据，因此数字以64位浮点值存储，即双精度的浮点数。</p>
<p>　　正如大家所料，javascript中没有你想使用的Integer(整型)类型。当我们需要用到integer类型时，javascript会内部执行 Toint32方法(浏览器内部函数，外部不可调用)将值直接转化为32位的integer以供调用，并将原值瞬间转换回双精度浮点型。</p>
<p>　　javascript与其他语言的不同之一就是它奇怪的位运算。</p>
<h2 id="细节请参考">细节请参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="external">Bitwise operators @ mozilla</a></p>
<p><a href="http://www.cnblogs.com/wisdomoon/p/3338327.html" target="_blank" rel="external">javascript位运算</a></p>
<p><a href="http://www.cnblogs.com/fengjun/archive/2012/01/16/2323413.html" target="_blank" rel="external">javascript位运算符</a></p>
<p><a href="http://www.zhihu.com/question/20546013" target="_blank" rel="external">知乎上关于javascript位运算性能的讨论</a></p>
<h2 id="位运算的应用">位运算的应用</h2><p><a href="http://www.doc88.com/p-998235083491.html" target="_blank" rel="external">位运算详解(介绍及用途)</a></p>
<p><a href="http://androiddeveloper.diandian.com/post/2012-06-07/40027080498" target="_blank" rel="external">“位运算”在程序开发中的妙用！</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/07/iOS8的CIDetector/" itemprop="url">
                iOS的CIDetector
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-07T18:04:52+08:00" content="2015-08-07">
            2015-08-07
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>前两天还在抱怨说为啥iOS不自带矩形识别之类的功能，今天就被抽脸了。</p>
<p>下午在<a href="https://github.com/Tim9Liu9/TimLiu-iOS#%E5%8A%A8%E7%94%BB" target="_blank" rel="external">Tim9Liu9的个人iOS开发总结项目</a>中发现了这个<a href="https://github.com/mmackh/IPDFCameraViewController" target="_blank" rel="external">IPDFCameraViewController</a>用的就是iOS自带的CIDetector功能，屌炸天了。</p>
<p><img src="https://raw.githubusercontent.com/mmackh/IPDFCameraViewController/master/mockup.png" alt="IPDFCameraViewController"></p>
<p>这个项目是InstaPDF公司开发的。他们以前的<a href="https://github.com/mmackh/MAImagePickerController-of-InstaPDF" target="_blank" rel="external">MAImagePickerController</a>项目确实用的也是OpenCV。</p>
<p>现在IPDFCameraViewController支持相机定焦拍摄、滤镜、闪光、实时边框检测以及透视矫正功能，并有简单易用的API。</p>
<p>CIDetector是CoreImage的功能，现在常用于人脸识别、笑容识别、QRCode识别等领域。</p>
<p><a href="http://developer.xamarin.com/guides/ios/platform_features/introduction_to_coreimage/" target="_blank" rel="external">xamarin上更多CoreImage的介绍</a></p>
<h2 id="补一篇介绍_2015-08-10">补一篇介绍 2015-08-10</h2><p><a href="https://www.shinobicontrols.com/blog/ios8-day-by-day-day-13-coreimage-detectors" target="_blank" rel="external">iOS8 Day-by-Day :: Day 13 :: CoreImage Detectors</a></p>
<h3 id="Detecting_Rectangles">Detecting Rectangles</h3><p>Detecting rectangles in images is often one of the first parts of a computer vision algorithm – whether it be automatic business card interpretation, or road sign processing. Although rectangle detection sounds like it should be a really simple process, as with many problems in computer vision, it’s far harder than you might expect. So it’s great that Apple have implemented an efficient algorithm as part of the CoreImage detectors.</p>
<p>The main class associated with CoreImage detectors is the aptly-named CIDetector. The same class is used for all the different types of detectors, and is instantiated with the CIDetector(ofType:, context:, options:) initializer. The type argument is a string, which for a rectangle detector is CIDetectorTypeRectangle. The options argument is a dictionary of settings associated with this detector. The following method created a CIDetector to be used for detecting rectangles:</p>
<pre><code>func prepareRectangleDetector() -&gt; CIDetector {
  let <span class="string">options:</span> [<span class="string">String :</span> AnyObject] = [<span class="string">CIDetectorAccuracy:</span> CIDetectorAccuracyHigh, <span class="string">CIDetectorAspectRatio:</span> <span class="number">1.0</span>]
  <span class="keyword">return</span> CIDetector(<span class="string">ofType:</span> CIDetectorTypeRectangle, <span class="string">context:</span> nil, <span class="string">options:</span> options)
}
</code></pre><p>You can see that the options here are specifying the accuracy as high, with the CIDetectorAccuracy key, and the CIDetectorAspectRatio key is used to specify that you’re searching for squares. This aspect ratio doesn’t mean that you’re only looking for squares, but it will be used in the ranking of possible rectangles to determine which is the most likely candidate. For example, if you know that you’re going to use the detector for business cards then setting the aspect ratio to 2.0 will likely yield better results.</p>
<p>Once you’ve created a CIDetector it’s actually really simple to use. The method featuresInImage() takes a CIImage and then returns an array of CIFeature objects (well, a subclass of) which represent the detected objects. In the case of a rectangle detector, the CIFeature subclass is CIRectangleFeature, which has CGPoint properties for each of the four corners of the detected rectangle.</p>
<p>The following method demonstrates how you can use the detector to find a rectangle in a supplied CIImage:</p>
<pre><code><span class="func"><span class="keyword">func</span> <span class="title">performRectangleDetection</span><span class="params">(image: CIImage)</span></span> -&gt; <span class="type">CIImage</span>? {
  <span class="keyword">var</span> resultImage: <span class="type">CIImage</span>?
  <span class="keyword">if</span> <span class="keyword">let</span> detector = detector {
<span class="comment">// Get the detections</span>
<span class="keyword">let</span> features = detector.featuresInImage(image)
<span class="keyword">for</span> feature <span class="keyword">in</span> features <span class="keyword">as</span>! [<span class="type">CIRectangleFeature</span>] {
  resultImage = drawHighlightOverlayForPoints(image, topLeft: feature.topLeft, topRight: feature.topRight,
                                              bottomLeft: feature.bottomLeft, bottomRight: feature.bottomRight)
}
  }
  <span class="keyword">return</span> resultImage
}
</code></pre><p>This unwraps the option detector, before using the featuresInImage() method to perform the detection itself. At the time of writing, the rectangle detector will only ever detect one rectangle in an image, so the features array will have either exactly one or zero CIRectangleFeature objects in it.</p>
<p>This method returns a new CIImage, which contains a red patch overlaid on the source image over the position of the detected rectangle. This uses the utility method drawHighlightOverlayForPoints() method:</p>
<pre><code>func drawHighlightOverlayForPoints(image: <span class="built_in">CIImage</span>, topLeft: <span class="built_in">CGPoint</span>, topRight: <span class="built_in">CGPoint</span>,
                               bottomLeft: <span class="built_in">CGPoint</span>, bottomRight: <span class="built_in">CGPoint</span>) -&gt; <span class="built_in">CIImage</span> {
  var overlay = <span class="built_in">CIImage</span>(color: <span class="built_in">CIColor</span>(red: <span class="number">1.0</span>, green: <span class="number">0</span>, blue: <span class="number">0</span>, alpha: <span class="number">0.5</span>))
  overlay = overlay<span class="variable">.imageByCroppingToRect</span>(image<span class="variable">.extent</span>())
  overlay = overlay<span class="variable">.imageByApplyingFilter</span>(<span class="string">"CIPerspectiveTransformWithExtent"</span>,
withInputParameters: [
  <span class="string">"inputExtent"</span>: <span class="built_in">CIVector</span>(<span class="built_in">CGRect</span>: image<span class="variable">.extent</span>()),
  <span class="string">"inputTopLeft"</span>: <span class="built_in">CIVector</span>(<span class="built_in">CGPoint</span>: topLeft),
  <span class="string">"inputTopRight"</span>: <span class="built_in">CIVector</span>(<span class="built_in">CGPoint</span>: topRight),
  <span class="string">"inputBottomLeft"</span>: <span class="built_in">CIVector</span>(<span class="built_in">CGPoint</span>: bottomLeft),
  <span class="string">"inputBottomRight"</span>: <span class="built_in">CIVector</span>(<span class="built_in">CGPoint</span>: bottomRight)
])
  <span class="keyword">return</span> overlay<span class="variable">.imageByCompositingOverImage</span>(image)
}
</code></pre><p>This method creates a colored image, and then uses the perspective transform filter to map it to the points provided. It then creates a new CIImage by overlaying this colored image with the source image.</p>
<p>In the LiveDetection sample project, the performRectangleDetection() method is used as part in the CoreImageVideoFilter class to run the detector on each of the frames received from the camera, before rendering it on screen. This class is a little more involved than you might expect it to be, and it isn’t within the scope of this article to go in to much detail, however an overview might be helpful.</p>
<p>An AVFoundation pipeline is created which uses the camera as input, and provides a pixel buffer of each frame to a delegate method.<br>In this delegate method a CIImage is created from this pixel buffer.<br>The provided filter function (which takes an input CIImage and returns a new CIImage, much like a map function) is passed the current image.<br>The image is cropped to match the view size it is to be rendered in.<br>The CIImage is then rendered on the OpenGLES surface using a pre-created CIRenderContext.<br>Rinse and repeat for each frame received from the camera.<br>If you need to do live video processing using CoreImage then it might be worth taking a look at this class in greater detail, but if you don’t then the performRectangleDetection() method just takes a CIImage, which you can create using one of the many constructors.</p>
<p>Running this app up will kick off the rectangle detection right away, and you’ll see results like the following on the screen:</p>
<p><img src="https://www.shinobicontrols.com/wp-content/uploads/2014/08/rectangle_detector.png" alt="Rectangle Detector"></p>
<p>The performance is pretty good for real-time use – certainly the demo app copes well on an iPad 3.</p>
<h2 id="另">另</h2><p>人家说至少要iOS8,iPhone5以上。</p>
<p>呵呵</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/03/Nodejs项目中用到的用户权限管理系统/" itemprop="url">
                Nodejs项目中用到的用户权限管理系统
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-03T18:26:02+08:00" content="2015-08-03">
            2015-08-03
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>权限管理，是管理系统中的常见组件。通常需要定义资源，把资源调配给用户，通过判断用户是否有权限增删改查来实现。</p>
<p><a href="https://en.wikipedia.org/wiki/Access_control_list" target="_blank" rel="external">ACL</a>：Access Control List，访问控制列表，是比较流行的设计方式。通过吧用户和权限挂钩来实现。</p>
<p><a href="https://en.wikipedia.org/wiki/Role-based_access_control" target="_blank" rel="external">RBAC</a>：Role Based Access Control，角色访问控制系统，是另一个实现思路。提炼出角色对象，把用户和角色绑定，角色来对应权限，角色和权限没有直接关联，对复杂的系统来说，更加容易管理。</p>
<h2 id="RBAC">RBAC</h2><p><img src="https://upload.wikimedia.org/wikipedia/en/c/c3/RBAC.jpg" alt="wiki"></p>
<p><img src="http://dl.iteye.com/upload/attachment/425543/d2573c4d-dca7-380f-b2fc-6cda19d6eaf5.jpg" alt=""></p>
<h2 id="资料">资料</h2><p><a href="http://rongxh2010.iteye.com/blog/930648" target="_blank" rel="external">扩展RBAC用户角色权限设计方案</a></p>
<p><a href="http://blog.csdn.net/tch918/article/details/18449043" target="_blank" rel="external">基于AOP实现权限管理：访问控制模型RBAC和ACL</a></p>
<p><a href="http://blog.csdn.net/gxp/article/details/6741652" target="_blank" rel="external">基于RBAC模型的权限管理系统的设计和实现</a></p>
<h2 id="node_实现">node 实现</h2><p>源自：<a href="https://gist.github.com/facultymatt/6370903" target="_blank" rel="external">这篇</a></p>
<p><a href="https://github.com/seeden/rbac" target="_blank" rel="external">https://github.com/seeden/rbac</a><br>Hierarchical Role Based Access Control for NodeJS</p>
<p><a href="https://github.com/djvirgen/virgen-acl" target="_blank" rel="external">https://github.com/djvirgen/virgen-acl</a><br>Simple and elegant, create your own checks. No middleware? </p>
<p><a href="https://github.com/OptimalBits/node_acl" target="_blank" rel="external">https://github.com/OptimalBits/node_acl</a><br>Use as middleware, create your own roles and access. Great choice. </p>
<p><a href="https://github.com/tschaub/authorized" target="_blank" rel="external">https://github.com/tschaub/authorized</a><br>Similar to connect roles… but a bit more robust? you can create roles and action, and associate many roles with that action</p>
<p><a href="https://github.com/scottkf/ability-js" target="_blank" rel="external">https://github.com/scottkf/ability-js</a><br>Like canCan for rails. This is a traditional controller / function type permission system. May be too abstract. </p>
<p><a href="https://github.com/dresende/node-roles" target="_blank" rel="external">https://github.com/dresende/node-roles</a><br>More traditional setRole() hasRole() based checking. Last activity 2 years ago. </p>
<p><a href="https://github.com/carlos8f/node-relations" target="_blank" rel="external">https://github.com/carlos8f/node-relations</a><br>Natural language style roles. Looks very promising and is in active development</p>
<p><a href="https://github.com/ForbesLindesay/connect-roles" target="_blank" rel="external">https://github.com/ForbesLindesay/connect-roles</a><br>Simple and closer to action / natural language based. Requires writing your own checks for each. </p>
<p><a href="https://github.com/ajlopez/SimplePermissions" target="_blank" rel="external">https://github.com/ajlopez/SimplePermissions</a><br>Maybe too simple? Makes sense for assigning roles but then its hard to check against roles! </p>
<p><a href="https://npmjs.org/package/entitlement" target="_blank" rel="external">https://npmjs.org/package/entitlement</a><br>Not ideal but here for reference sake.</p>
<h2 id="Mongoose_Field_Access_Control">Mongoose Field Access Control</h2><p><a href="https://github.com/codedoctor/mongoose-plugins-accessible-by" target="_blank" rel="external">https://github.com/codedoctor/mongoose-plugins-accessible-by</a> Set access per field of mongoose Schema. Not supported or maintained, and noted as not a perfect fit in all cases… but worth considering as a simple way to control access to fields. </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/08/03/图形拼接技术：OpenCV-SIFT/" itemprop="url">
                图形拼接技术：OpenCV, SIFT
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-08-03T13:22:09+08:00" content="2015-08-03">
            2015-08-03
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>某天，嘴炮打的太嗨，说可以用APP识别连续拍的几个图片，然后拼接起来，就像iPhone自带的那个全景拍照模式，Panorama mode。<a href="http://stackoverflow.com/questions/14062932/libraries-to-capture-panorama-in-ios-6" target="_blank" rel="external">很多人也在问</a>。</p>
<p><img src="https://github.com/foundry/OpenCVSwiftStitch/raw/meta/meta/example.big.jpg" alt=""></p>
<h2 id="OpenCV">OpenCV</h2><p>发现OpenCV里已经集成了一个stitch，附上<a href="https://github.com/foundry/OpenCVStitch" target="_blank" rel="external">找到的例程代码</a>。</p>
<h2 id="SIFT">SIFT</h2><p>网上搜到，说叫Rob Hess的大神搞了个基于OpenCV的SIFT算法。这个<a href="https://en.wikipedia.org/wiki/Scale-invariant_feature_transform" target="_blank" rel="external">SIFT</a>(<a href="http://blog.csdn.net/pi9nc/article/details/9251387" target="_blank" rel="external">中文介绍</a>)据说是碉堡扎天的很，通过比对特征点，来拼接图片。<a href="https://github.com/search?l=C%2B%2B&amp;o=desc&amp;q=SIFT&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93" target="_blank" rel="external">github</a>上面的有很多应用。</p>
<p><a href="http://ppwwyyxx.com/2013/SIFT-and-Image-Stiching/" target="_blank" rel="external">另一篇中文SIFT使用的介绍</a>，<a href="http://github.com/ppwwyyxx/panorama" target="_blank" rel="external">他的例程</a></p>
<p><img src="https://github.com/ppwwyyxx/panorama/raw/master/results/small/apartment.jpg" alt="例子"></p>
<p>这有个例子<a href="http://www.cs.bath.ac.uk/brown/autostitch/autostitch.html" target="_blank" rel="external">AutoStitch</a>，据说可以免费用，有MAC版，而且我手机拍的照片直接就拼起来了，敬仰啊。可惜这个找不到源码。</p>
<p><img src="http://www.cs.bath.ac.uk/brown/autostitch/half950.jpg" alt="例子"></p>
<p><img src="http://www.cs.bath.ac.uk/brown/autostitch/serratus950.jpg" alt="例子"></p>
<p>然后又发现一个叫<a href="http://hugin.sourceforge.net/" target="_blank" rel="external">Hugin</a>的，好像很了得，就是太大了，不知道怎么搞进APP里去。</p>
<h2 id="K-Means,_RANSAC">K-Means, RANSAC</h2><p>这俩是什么鬼完全不懂了～好吧，谷歌一下之后发现K-Means是聚类算法，RANSAC是什么随机一致性什么什么算法。  ：（</p>
<h2 id="总之">总之</h2><p><a href="http://mi.eng.cam.ac.uk/~cipolla/lectures/4F12/Slides/4F12-ImageStitching.pdf" target="_blank" rel="external">一个PDF快速了解关键点～</a></p>
<p><code>为什么在avfoundation就没有接口啊，擦！直接开出来大家不都可以直接用了嘛！差评！</code></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/07/30/研究现代浏览器的几片文章/" itemprop="url">
                研究现代浏览器的几篇文章
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-07-30T09:49:20+08:00" content="2015-07-30">
            2015-07-30
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>曾经看到过一篇鸡汤文，说如果有什么事情你很想做，但是又怕坚持不下来，那么就去告诉你的朋友们，让他们来监督你鞭策你甚至嘲笑你：比如100天不撸什么的。</p>
<p>我呢，一直以来都想DIY一个浏览器，现代的，支持HTML5、CSS3、ES6什么的，反正得是高级的，可是我目前的状态是c++不懂，真心不懂。</p>
<p>不过我可以先收集起来，说不定哪天我看完了《c++ primer plus》就可以搞了。</p>
<h2 id="几篇文章">几篇文章</h2><p><a href="http://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="external">html5rocks:浏览器的工作原理：新式网络浏览器幕后揭秘</a></p>
<p><a href="http://kyleslight.net/article/7" target="_blank" rel="external">浏览器的工作原理 - 现代浏览器背后的风景</a>  上面的另一翻译版</p>
<p><a href="http://blog.sina.com.cn/s/blog_682793a50100t40p.html" target="_blank" rel="external">翻译-现代浏览器的架构与发展</a></p>
<h2 id="浏览器相关的项目">浏览器相关的项目</h2><p><a href="https://github.com/v8/v8" target="_blank" rel="external">V8</a> 对的，就是这个</p>
<p><a href="https://github.com/WebKit/webkit" target="_blank" rel="external">WebKit</a> 对的，就是这个，好屌</p>
<p><a href="https://hg.mozilla.org/" target="_blank" rel="external">mozilla</a> 里面好多东西，都不知是啥。</p>
<p><a href="https://github.com/google/gumbo-parser" target="_blank" rel="external">An HTML5 parsing library in pure C99</a> 谷歌家的HTML5解析，无需其他依赖，<a href="http://blog.csdn.net/huareal/article/details/9970841" target="_blank" rel="external">中文介绍</a></p>
<p><a href="https://github.com/AaronShea/BLUI" target="_blank" rel="external">BLUI: HTML powered UI and HUD for Unreal Engine 4</a> 名字好屌，但是不明白是啥</p>
<p><a href="https://github.com/CzarekTomczak/cef2go" target="_blank" rel="external">CEF2go is an HTML 5 based GUI toolkit for the Go language.</a></p>
<p><a href="https://github.com/libRocket/libRocket" target="_blank" rel="external">libRocket - The HTML/CSS User Interface Library</a></p>
<p><a href="https://github.com/trevorlinton/webkit.js" target="_blank" rel="external">Pure JavaScript Port of WebKit</a> 其实我不知道这是什么贵</p>
<p><a href="https://github.com/Athari/CsCss" target="_blank" rel="external">CSS parsing library for C# based on Mozilla Firefox code [MPL]</a> c#的，什么贵</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/07/28/Opencv-应用，图片里取出四边形/" itemprop="url">
                Opencv应用，图片里取出四边形
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          發表於
          <time itemprop="dateCreated" datetime="2015-07-28T10:18:26+08:00" content="2015-07-28">
            2015-07-28
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分類於
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/opencv/" itemprop="url" rel="index"><span itemprop="name">opencv</span></a></span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>有这样一个需求，在桌上有张纸，可能是票据，合同什么的，用手机咔嚓咔嚓拍下来，然后自动把纸张缩放到合适的大小。可是拍的时候有可能是歪的，不一定就对的很正，桌子也可能是有花纹啊，边上有小干扰物啥的。</p>
<p>这要是做APP的话，可怎么搞，总之是要检测纸张边缘，取出四边形，然后拉伸成规则长方形。</p>
<p>好像选opencv是必然的，还有更好的选择吗？</p>
<h2 id="图像预处理">图像预处理</h2><p>据说通常都要对图像进行降噪避免误测，常见的做法是先进行高斯模糊，然而这并没有什么卵用，会把图像弄模糊，边界都不清楚就没法玩了。所以有人说，可以用Mean Shift，Mean Shift的优点就在于如果是像背景桌面的浅色纹理，图像分割的过程中相当于将这些小的浮动过滤掉，并且保留相对明显的纸张边缘，结果如下：</p>
<p>原图</p>
<p><img src="http://www.linuxidc.com/upload/2015_01/150118102418484.png" alt="原图"></p>
<p>处理后</p>
<p><img src="http://www.linuxidc.com/upload/2015_01/150118102418485.png" alt="处理后"></p>
<p>顺便说一句，现在手机分辨率好高，直接处理这么大的图片会比较消耗资源，把图缩小之后处理速度会提升，而且也变相消除了部分干扰。</p>
<h2 id="边缘检测">边缘检测</h2><p>边缘检测这一步，最好是能有人工干预，把大范围标出来，类似这样：</p>
<p><img src="http://www.linuxidc.com/upload/2015_01/150118102418486.png" alt="类似"></p>
<p>但实际上这样的用户体验肯定是负分了，所以假设用户的桌面不会这么极端，而是使用相对整洁的桌面并且纸张放置相对规整，类似这样的：<br><img src="http://ww3.sinaimg.cn/large/6cea169fjw1edorxi2nqqj20dc0hs414.jpg" alt="类似"></p>
<p>这样就不需要用GrabCut做分割，而是直接灰度处理后用canny算子检测边缘。</p>
<pre><code><span class="comment">// bw is the grayscaled source image</span>
cv<span class="tag">::Canny</span>(<span class="literal">bw</span>, <span class="literal">bw</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">3</span>);
</code></pre><p>得到边缘图：</p>
<p><img src="http://ww4.sinaimg.cn/large/6cea169fjw1edorxrxncwj205k07ewf3.jpg" alt="边缘图"></p>
<h2 id="直线检测">直线检测</h2><p>直线检测就是利用概率霍夫变换累加求出图像中的直线，看<a href="http://blog.csdn.net/zhaocj/article/details/40047397" target="_blank" rel="external">介绍</a>和<a href="http://www.tuicool.com/articles/Mn2EBn" target="_blank" rel="external">介绍2</a>。这里我们可以对后面的参数做些微调，在我们的参数里，假设了纸张的宽度和高度都接近边缘，并且各自至少大于画面宽高的一半，那么过短的线就可以直接抛弃了。</p>
<pre><code><span class="comment">// w_proc 就是缩小后的画面宽度，20是把间距20以内的线段延长拼接为一条直线</span>
HoughLinesP<span class="params">(bw, lines, <span class="number">1</span>, CV_<span class="literal">PI</span> / <span class="number">180</span>, w_proc / <span class="number">2</span>, w_proc / <span class="number">2</span>, <span class="number">20</span>)</span>;
</code></pre><p>顺利的得到了这个：</p>
<p><img src="http://ww4.sinaimg.cn/large/6cea169fjw1edp0p51cs6j205k07eq3o.jpg" alt="线图"></p>
<h2 id="判断有效多边形">判断有效多边形</h2><p>上例中的lines，就是我们得到的所有线的集合，每条线包含点的偏移和向量。<br>如何判断其中哪些是有效的多边形，或者说我们要的多边形，对我来说蛮纠结的。有的<a href="http://opencv-code.com/tutorials/automatic-perspective-correction-for-quadrilateral-objects/" target="_blank" rel="external">例子</a>里直接HoughLinesP跑完就有了，我测试的图基本都不行。</p>
<p><a href="http://daisygao.com/2014/02/17/%E7%94%A8opencv%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8Bcamscanner/" target="_blank" rel="external">这里</a>的方法是把所有横向的线中取最上和最下两条，纵向线中取最左和最右两条。这里是基于纸张正放的假设，如果侧放就不行了，例如这样的</p>
<p><img src="http://opencv-code.com/wp-content/uploads/perspective-quadrilateral-src-img.jpg" alt="很难这样测出来的"></p>
<h2 id="求四顶点坐标">求四顶点坐标</h2><p>总之不管三七二十一，我们有了四边形的四条边。两两相交有6个点，除去画面外的两个，剩下的四个点就是我们要的四个顶点了。</p>
<p>使用这个<a href="http://en.wikipedia.org/wiki/Line_intersection" target="_blank" rel="external">公式</a>，带入两条直线上的两个点坐标。</p>
<p><img src="http://opencv-code.com/wp-content/uploads/perspective-quadrilateral-line-intersections-equation.png" alt="公式"></p>
<h2 id="透视转换">透视转换</h2><p><img src="http://opencv-code.com/wp-content/uploads/perspective-quadrilateral-match-corners.png" alt="转换"></p>
<p>用<code>getPerspectiveTransform</code>计算转化矩阵，再用<code>warpPerspective</code>调用转化矩阵进行拉伸。</p>
<h2 id="代码">代码</h2><p>制作了一个简单的例程。</p>
<p><a href="https://github.com/vitrum/opencv-demo" target="_blank" rel="external">github</a></p>
<p>参考资料：</p>
<p><a href="http://daisygao.com/2014/02/17/%E7%94%A8opencv%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8F%E5%85%A8%E8%83%BD%E7%8E%8Bcamscanner/" target="_blank" rel="external">用OpenCV实现“扫描全能王”APP</a></p>
<p><a href="http://www.linuxidc.com/Linux/2015-01/111962.htm" target="_blank" rel="external">利用OpenCV检测图像中的长方形画布或纸张并提取图像内容</a>好像原帖在知乎上</p>
<p><a href="http://opencv-code.com/tutorials/automatic-perspective-correction-for-quadrilateral-objects/" target="_blank" rel="external">Automatic perspective correction for quadrilateral objects</a><br>注：我是觉得这篇里硬要凑4条线拼一个四边形有点难，还是检测出一些，然后判断抛弃一些比较好。</p>
<p><a href="http://blog.csdn.net/mysteryrat/article/details/8955229" target="_blank" rel="external">自动透视校正为四边形对象</a> 上一篇加了写中文注释。</p>
<p><a href="http://blog.163.com/liangq_11/blog/static/35743824201092242725214/" target="_blank" rel="external">深入剖析mean shift 图像分割 原理及代码</a> </p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/67/">67</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>


            </div>

            

            
        </div>

        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="https://avatars3.githubusercontent.com/u/401767?v=3&s=140" alt="Vitrum Zhu" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Vitrum Zhu</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">663</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">分類</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">37</span>
              <span class="site-state-item-name">標籤</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/vitrum" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/vitrum" target="_blank">Twitter</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/vitrum" target="_blank">Weibo</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
        <div class="footer-inner">
            <div class="copyright" >
  
  &copy; &nbsp;  2005 - 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vitrum Zhu</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



        </div>
    </footer>

    <div class="back-to-top"></div>
</div>

<script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"vitrum.duoshuo.com"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.4"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.4"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.4" id="motion.global"></script>



  <script type="text/javascript" src="/js/search-toggle.js"></script>



<script type="text/javascript">
    $(document).ready(function () {
        if (CONFIG.sidebar === 'always') {
            displaySidebar();
        }
    });
</script>




  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"vitrum.duoshuo.com"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

  





<!-- lazyload -->
<script type="text/javascript" src="/js/lazyload.js"></script>
<script type="text/javascript">
    jQuery(function () {
        jQuery("#posts img").lazyload({
            placeholder: "/images/loading.gif",
            effect: "fadeIn"
        });
    });
</script>
</body>
</html>
